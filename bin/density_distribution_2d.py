#!/usr/bin/python2.6
#$ -S /usr/bin/python2.6

from optparse import OptionParser
import sys
import re
import collections
import math


def analyze_run(fn_pore_crd_h, fn_pore_crd_r, atomnames,
                grid_width_h, grid_width_r, time_begin, time_end, flg_verbose):
    try: f_crd_h = open(fn_pore_crd_h,'r')
    except IOError:
        sys.stderr.write("Error: File "+fn_pore_crd_h+" could not be opened.\n")
        sys.exit()
    try: f_crd_r = open(fn_pore_crd_r,'r')
    except IOError:
        sys.stderr.write("Error: File "+fn_pore_crd_r+" could not be opened.\n")
        sys.exit()

    grid = {}
    for atom in atomnames:
        grid[atom] = collections.defaultdict(int)

    head = f_crd_h.readline()
    terms = re.compile("\s+").split(head.strip())
    
    column_atom = {}
    for i,term in enumerate(terms):
        tmp = re.compile(":").split(term)
        atom = tmp[1]
        if atom in atomnames:
            column_atom[i] = atom

    head = f_crd_r.readline()    
    
    max_grid_pos_h = -1e100
    max_grid_pos_r = -1e100
    min_grid_pos_h = 0
    min_grid_pos_r = 1e100
    for i,line_h in enumerate(f_crd_h):
        line_r = f_crd_r.readline()
        terms_h = re.compile("\s+").split(line_h.strip())
        terms_r = re.compile("\s+").split(line_r.strip())
        time = float(terms_h[0])
        if flg_verbose and i%10000==0: print "time: " + str(time)
        if time_begin >= 0 and time < time_begin: continue
        if time_end >= 0 and time >= time_end: break
        for j, term_h in enumerate(terms_h[1:]):
            if not j in column_atom: continue
            
            term_r = terms_r[j+1]
            if term_h == '-' or term_r == '-': continue
            grid_pos_h = int(math.floor(float(term_h) / grid_width_h))
            grid_pos_r = int(math.floor(float(term_r) / grid_width_r))    
            grid[column_atom[j]][(grid_pos_h,grid_pos_r)] += 1
            if grid_pos_h > max_grid_pos_h: max_grid_pos_h = grid_pos_h
            if grid_pos_h < min_grid_pos_h: min_grid_pos_h = grid_pos_h
            if grid_pos_r > max_grid_pos_r: max_grid_pos_r = grid_pos_r
            if grid_pos_r < min_grid_pos_r: min_grid_pos_r = grid_pos_r
            
    f_crd_h.close()
    f_crd_r.close()
    return grid, min_grid_pos_h, max_grid_pos_h, min_grid_pos_r, max_grid_pos_r
    
def output_grid(fn_out, grid, grid_width_h, grid_width_r,
                min_grid_pos_h, max_grid_pos_h,
                min_grid_pos_r, max_grid_pos_r):
    f_out = open(fn_out,'w')
    header = []
    for r in range(min_grid_pos_r, max_grid_pos_r):
        header.append(str(r*grid_width_r))
    f_out.write('\t'.join(header) + '\n')

    for h in range(min_grid_pos_h, max_grid_pos_h):
        f_out.write(str(h*grid_width_h))
        for r in range(min_grid_pos_r, max_grid_pos_r):
            f_out.write('\t'+str(grid[(h,r)]))
        f_out.write('\n')
    f_out.close()
    
def _main():
    p = OptionParser()
    p.add_option('--i-pore-crd-h', dest='fn_pore_crd_h',
                 help="file name for pore axis coordinates h generated by trachan.")
    p.add_option('--i-pore-crd-r', dest='fn_pore_crd_r',
                 help="file name for pore axis coordinates r generated by trachan.")
    p.add_option('--o-density', dest='fn_density',
                 default="density_distribution_2d.txt",
                 help="output file name for density distribution.")
    p.add_option('-a','--atomname', dest='atomnames',
                 action="append",
                 help="atom name to be considered")
    p.add_option('--grid-w-h', dest='grid_width_h',
                 type="float",
                 default=0.01,
                 help="grid width in h axis for density distribution")
    p.add_option('--grid-w-r', dest='grid_width_r',
                 type="float",
                 default=0.01,
                 help="grid width in r axis for density distribution")
    p.add_option('-b','--begin', dest='time_begin',
                 type="float", default=-1,
                 help="first time to be considered in ps")
    p.add_option('-e','--end', dest='time_end',
                 type="float", default=-1,
                 help="last time to be considered in ps")
    p.add_option('-v', dest='flg_verbose',
                 action="store_true",
                 help="print verbose information to stdout.")
    opts, args = p.parse_args()

    flg_fail = False
    if not opts.fn_pore_crd_h or not opts.fn_pore_crd_r:
        sys.stderr.write("Error: Both the options '--i-pore-crd-h' and '--i-pore-crd-r' are required.\n")
        flg_fail=True
    if flg_fail:
        exit(1)


    grid, min_grid_h, max_grid_h, min_grid_r, max_grid_r = \
          analyze_run(opts.fn_pore_crd_h, opts.fn_pore_crd_r, opts.atomnames,
                      opts.grid_width_h, opts.grid_width_r,
                      opts.time_begin, opts.time_end,
                      opts.flg_verbose)

    if opts.flg_verbose:
        print "output " + opts.fn_density

    for atom in opts.atomnames:
        output_grid(opts.fn_density+'.'+atom, grid[atom],
                    opts.grid_width_h, opts.grid_width_r,
                    min_grid_h, max_grid_h,
                    min_grid_r, max_grid_r)
        
if __name__ == '__main__':
    _main()
